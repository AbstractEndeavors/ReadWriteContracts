"/**\r\n *Submitted for verification at snowtrace.io on 2022-08-19\r\n*/\r\n\r\n/**\r\n *Submitted for verification at snowtrace.io on 2022-08-19\r\n*/\r\n\r\n// Sources flattened with hardhat v2.3.0 https://hardhat.org\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.6.0\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC165 {\r\n    \r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.6.0\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    \r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.6.0\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\npragma solidity ^0.8.1;\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n        return account.code.length > 0;\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.6.0\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.6.0\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    \r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n    \r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n    \r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.6.0\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    \r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v4.6.0\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC1155 is IERC165 {\r\n    \r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    \r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    \r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    \r\n    event URI(string value, uint256 indexed id);\r\n    \r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    \r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    \r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    \r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n    \r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol@v4.6.0\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    \r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n    \r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// File @openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol@v4.6.0\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    \r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n// File @openzeppelin/contracts/token/ERC1155/ERC1155.sol@v4.6.0\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\r\npragma solidity ^0.8.0;\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n    \r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n    \r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n    \r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n    \r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n        return batchBalances;\r\n    }\r\n    \r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n    \r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n    \r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n    \r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n    \r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n    \r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        address operator = _msgSender();\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n    \r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n    \r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\r\n    }\r\n    \r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        address operator = _msgSender();\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n    \r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n    \r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        address operator = _msgSender();\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n    \r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n    \r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n    \r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n        return array;\r\n    }\r\n}\r\n// File @openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol@v4.6.0\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\r\npragma solidity ^0.8.0;\r\nabstract contract ERC1155Burnable is ERC1155 {\r\n    function burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 value\r\n    ) public virtual {\r\n        require(\r\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _burn(account, id, value);\r\n    }\r\n    function burnBatch(\r\n        address account,\r\n        uint256[] memory ids,\r\n        uint256[] memory values\r\n    ) public virtual {\r\n        require(\r\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _burnBatch(account, ids, values);\r\n    }\r\n}\r\n// File @openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol@v4.6.0\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ERC1155Supply is ERC1155 {\r\n    mapping(uint256 => uint256) private _totalSupply;\r\n    \r\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\r\n        return _totalSupply[id];\r\n    }\r\n    \r\n    function exists(uint256 id) public view virtual returns (bool) {\r\n        return ERC1155Supply.totalSupply(id) > 0;\r\n    }\r\n    \r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n        if (from == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                _totalSupply[ids[i]] += amounts[i];\r\n            }\r\n        }\r\n        if (to == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                uint256 id = ids[i];\r\n                uint256 amount = amounts[i];\r\n                uint256 supply = _totalSupply[id];\r\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\r\n                unchecked {\r\n                    _totalSupply[id] = supply - amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\npragma solidity ^0.8.4;\r\ncontract NeFiNFT is ERC1155, Ownable, ERC1155Burnable, ERC1155Supply {\r\n    uint256 public constant RedGiant = 1;\r\n    uint256 public constant WhiteDwarf = 2;\r\n    uint256 public constant SuperNova = 3;\r\n    uint256 public Zero = 0;\r\n    string public name;\r\n    string public symbol;\r\n    string public uri_RedGiant;\r\n    string public uri_WhiteDwarf;\r\n    string public uri_SuperNova;\r\n    uint256 public redgiant;\r\n    uint256 public whitedwarf;\r\n    uint256 public supernova;\r\n    address public token;\r\n    uint256 public strange;\r\n    string[] public uri_ls = [\"https://bafybeigx4nhmkybcnrnkgyuyrnzv536l4wop2rknyxhelq357qrc57oqii.ipfs.nftstorage.link/1.json\",\"https://bafybeiefohsdkww5tvpj7bfjasuoznnig5xbouhsnaoz2mgzvoqi2lnjai.ipfs.nftstorage.link/2.json\",\"https://bafybeigmuj6hxvou4rmjuho2yg2gga6l4rcfesvprgzvogchogpg4apdf4.ipfs.nftstorage.link/3.json\"];\r\n    uint256[] public NFTids = [RedGiant,WhiteDwarf,SuperNova];\r\n    modifier managerOnly() {require(isInList(msg.sender, Managers)== true); _;}\r\n    modifier onlyGuard() {require(owner() == _msgSender() || token == _msgSender(), \"NOT_GUARD\");_;}\r\n    address[] private Managers;\r\n    constructor() ERC1155(uri_ls[0]) {\r\n\tname = \"NeFiProtoStars\";\r\n\tsymbol = \"NeFiNFT\";\r\n    }\r\n    function isInList(address _account, address[] memory list) internal returns(bool){\r\n    \tfor(uint i=0;i<list.length;i++){\r\n    \t\tif(_account == list[i]){\r\n    \t\t\treturn true;\r\n    \t\t}\r\n    \t}\r\n    \treturn false;\r\n    }\r\n    function checkTots() external view returns(uint256[3] memory){\r\n    \treturn [redgiant,whitedwarf,supernova];\r\n    }\r\n    function setURI(uint256 k) public onlyOwner {\r\n        require(k > 0 && k < 4,\"thats not in the stars\");\r\n\t\t_setURI(uri_ls[k-1]);\r\n    }\r\n    function PsetURI(uint256 k) public onlyGuard {\r\n        require(k > 0 && k < 4,\"thats not in the stars\");\r\n\t\t_setURI(uri_ls[k-1]);\r\n    }\r\n    function recTotes(uint256 _id, uint256 _amount) internal {\r\n    \tuint256[3] memory ls = [Zero,Zero,Zero];\r\n    \tfor(uint i=0;i<ls.length;i++){\r\n\t\tif(i == _id-1){\r\n\t\t\tls[i] = _amount;\r\n\t\t}\r\n\t\t    \t\r\n    \t}\r\n    \tredgiant += ls[0];\r\n    \twhitedwarf += ls[1];\r\n    \tsupernova += ls[2];\r\n    }\r\n    function Pmint(address _account, uint256 _id, uint256 _amount, bytes memory data)\r\n        public\r\n        onlyGuard\r\n    {\r\n    \t    recTotes(_id,_amount);\r\n    \t    _setURI(uri_ls[_id - 1]);\r\n    \t    \r\n    \t\r\n        \r\n    }\r\n    function mint(address _account, uint256 _id, uint256 _amount, bytes memory data)\r\n        public\r\n        onlyOwner\r\n    {\r\n    \t    recTotes(_id,_amount);\r\n    \t    _setURI(uri_ls[_id - 1]);\r\n    \t    _mint(_account, _id, _amount, data);\r\n    \t\r\n        \r\n    }\r\n    function mintBatch(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory data)\r\n        public\r\n        managerOnly\r\n    {\t\r\n    \t\r\n    \tfor(uint i=0;i<_ids.length;i++){\r\n    \t\tmint(_to,_ids[i],_amounts[i],data);\r\n    \t}\r\n\t \r\n        \r\n    }\r\n    // The following functions are overrides required by Solidity.\r\n    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)\r\n        internal\r\n        override(ERC1155, ERC1155Supply) \r\n    {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n    }\r\n    \r\n    fallback() external payable {}\r\n\r\n\t\r\n    // Function to receive Ether. msg.data must be empty\r\n    receive() external payable {}\r\n\r\n\r\n    function getBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }    \r\n    function updateToken(address newToken) external managerOnly {\r\n        token = newToken;\r\n    }\r\n    function updateManager(address man) external onlyOwner {\r\n        Managers.push(man);\r\n    }\r\n}"